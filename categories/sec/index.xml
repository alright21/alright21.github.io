<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sec on Alberto Giust</title><link>https://blog.alright21.me/categories/sec/</link><description>Recent content in Sec on Alberto Giust</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 29 Feb 2024 08:30:26 +0100</lastBuildDate><atom:link href="https://blog.alright21.me/categories/sec/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploiting Exported Services: IPC Messenger</title><link>https://blog.alright21.me/security/exploiting_ipc_messenger/</link><pubDate>Thu, 29 Feb 2024 08:30:26 +0100</pubDate><guid>https://blog.alright21.me/security/exploiting_ipc_messenger/</guid><description>&lt;p>Hello everyone! It&amp;rsquo;s &lt;code>alright&lt;/code> here. In this article we will explore the concepts of exported components, bound services, and IPC (Inter-Process Communication) in Android, what are the risks associated to them and how we can exploit them when misconfigured. I will share a vulnerable application based on a real life example I encountered during my daily job.&lt;/p>
&lt;p>Prepare your Android knowledge and let&amp;rsquo;s get started.&lt;/p>
&lt;h2 id="what-is-a-service">What is a Service&lt;/h2>
&lt;p>A &lt;a href="https://developer.android.com/reference/android/app/Service">&lt;code>Service&lt;/code>&lt;/a> is an application component used to perform actions in background. A service does not run on a separate process or a separate thread and does not need a user interface. They are used for sending notifications, manage audio playback or create persistent connection between multiple processes for service-client communication. In this article we will focus our study on bound services used for inter-process communication.&lt;/p></description></item><item><title>Extract App Information from APK and IPA Package</title><link>https://blog.alright21.me/security/mobile_extract_info/</link><pubDate>Sun, 07 Jan 2024 10:15:31 +0100</pubDate><guid>https://blog.alright21.me/security/mobile_extract_info/</guid><description>&lt;p>During my mobile security journey, I often get stuck when searching for the publicly known app information that I am testing. We are talking about app name, app main package, version number and build. This information is important for reporting: I usually fire up my MobsF Docker instance and get this information from there. This process is often too slow, especially for big applications: I often forget to note down this data before turning off the Docker instance:(&lt;/p></description></item><item><title>Reversing and Hooking Native Libraries in Android with Frida</title><link>https://blog.alright21.me/security/mobile_security_native/</link><pubDate>Thu, 26 Oct 2023 18:01:16 +0200</pubDate><guid>https://blog.alright21.me/security/mobile_security_native/</guid><description>&lt;p>Android applications are written in Java (Kotlin): we can use tools like jadx to decompile Java smali code to analyze the code, identify interesting methods and find possible secrets.&lt;/p>
&lt;p>In some cases, Android applications use native libraries to perform some specific tasks: they may be used for root detection, or they can also be responsible for encryption, or simply to run simple tasks, like hide secrets. We can find libraries used inside the apk, by unpacking the &lt;code>.apk&lt;/code> using &lt;code>apktool d&lt;/code>, inside the &lt;code>/lib&lt;/code> folder. Native means that each library is compiled based on the hardware architecture the application will run on, meaning that we will have different folders with the same libraries, but compiled for different architectures.&lt;/p></description></item><item><title>Intercepting Non-HTTP Traffic in Android</title><link>https://blog.alright21.me/security/mobile_nohttp/</link><pubDate>Wed, 06 Sep 2023 12:25:03 +0200</pubDate><guid>https://blog.alright21.me/security/mobile_nohttp/</guid><description>&lt;p>Recently I have started solving a mobile security CTF called &lt;a href="https://ctf.hpandro.raviramesh.info/">hpAndro&lt;/a> and I stumbled upon two challenges focusing on intercepting non-HTTP traffic in Android. I tried to check if I could do it by setting up Wireshark on my laptop and detect this communication directly from that, but it was not working.&lt;/p>
&lt;p>I thought I could change my perspective and monitor traffic directly from my device (it is always Linux). In this short article, I will show two methodologies I found to monitor app traffic, especially non-HTTP one.&lt;/p></description></item><item><title>Intercepting Traffic in Mobile Flutter Applications</title><link>https://blog.alright21.me/security/mobile_flutter/</link><pubDate>Tue, 01 Aug 2023 08:50:38 +0200</pubDate><guid>https://blog.alright21.me/security/mobile_flutter/</guid><description>&lt;p>During our tests, it may happen that we have to find vulnerabilities in applications built with the Flutter framework. It is pretty common when we have both Android and iOS apps. This framework raises some problems when we need to intercept traffic for two reasons:&lt;/p>
&lt;ol>
&lt;li>flutter apps are proxy unaware - if we add a proxy listener from the settings of our phone, the application will ignore it&lt;/li>
&lt;li>flutter apps often implement ssl pinning techniques that are not easily bypassed using standard frida scripts&lt;/li>
&lt;/ol>
&lt;p>Below are explained the solutions for Android and iOS. For iOS, I will explain the procedure
that the researchers from &lt;a href="https://www.nviso.eu/">nviso&lt;/a> suggest in their articles (Android[1] and iOS[2]) and article. They have full credit over this, I will add some comments on what was not immediately clear to me:)&lt;/p></description></item><item><title>Mobile Security Introduction</title><link>https://blog.alright21.me/security/mobile_security_intro/</link><pubDate>Sun, 23 Jul 2023 18:00:00 +0200</pubDate><guid>https://blog.alright21.me/security/mobile_security_intro/</guid><description>&lt;p>After quite a while, I finally decided to upload this article. If you come across any inconsistencies, I am always open to feedback. I will continuously update it, aiming to create a comprehensive &amp;ldquo;Mobile Security Introduction Garden&amp;rdquo;. Have fun reading! :)&lt;/p>
&lt;p>The world of mobile application security requires to have different skills and knowledge compared to web application testing because we are also dealing with a client installed on our device that handles user input, and often communicates with a backend server. Apart from API testing knowledge, we also need a special setup, a real or emulated device, some ways to view the application code and to interact dynamically with the app while running. There are two main OS in the world of mobile security: Android and iOS. For now, we won&amp;rsquo;t explain the architecture in this article. When we are dealing with the same app built for these two OS, we will notice some similarities (backend communication), and some differences (client analysis).&lt;/p></description></item></channel></rss>