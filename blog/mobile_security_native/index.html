<!doctype html><html lang=en-us><head><link rel=stylesheet href=/styles.css><link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Reversing and Hooking Native Libraries in Android with Frida | Alberto Giust</title>
<link rel=canonical href=https://alright21.github.io/blog/mobile_security_native/><meta name=description content="Hi, I am Alberto Giust, aka `alright(21)?`, penetration tester at Spike Reply and security enthusiast. In this website you will find CTF writeups and other interesting things I want to document about my journey through the magical world of Cybersecurity."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="Reversing and Hooking Native Libraries in Android with Frida"><meta property="og:description" content="Reversing and Hooking Native Libraries in Android with Frida Android applications are written in Java (Kotlin): we can use tools like jadx to decompile Java smali code to analyze the code, identify interesting methods and find possible secrets.
In some cases, Android applications use native libraries to perform some specific tasks: they may be used for root detection, or they can also be responsible for encryption, or simply to run simple tasks, like hide secrets."><meta property="og:type" content="article"><meta property="og:url" content="https://alright21.github.io/blog/mobile_security_native/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-10-26T18:01:16+02:00"><meta property="article:modified_time" content="2023-10-26T18:01:16+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reversing and Hooking Native Libraries in Android with Frida"><meta name=twitter:description content="Reversing and Hooking Native Libraries in Android with Frida Android applications are written in Java (Kotlin): we can use tools like jadx to decompile Java smali code to analyze the code, identify interesting methods and find possible secrets.
In some cases, Android applications use native libraries to perform some specific tasks: they may be used for root detection, or they can also be responsible for encryption, or simply to run simple tasks, like hide secrets."><link rel=stylesheet href=https://alright21.github.io/css/styles.e282735e308195f4ba7bde9c23d7b770c438e682fdb8dd70ed9a1cc443b0ba4ce94a817547eb664fefe53bc615142aa923a0f8f94bb58b5f2441d213e6d7d0a9.css integrity="sha512-4oJzXjCBlfS6e96cI9e3cMQ45oL9uN1w7ZocxEOwukzpSoF1R+tmT+/lO8YVFCqpI6D4+Uu1i18kQdIT5tfQqQ=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://alright21.github.io/favicon.ico><div id=cookie-notice><span>We would like to use third party cookies and scripts to improve the
functionality of this website.</span>
<a id=cookie-notice-accept class="btn btn-primary btn-sm">Approve</a>
<a id=cookie-notice-deny class="btn btn-primary btn-sm">Deny</a>
<a href=/privacy id=cookie-notice-privacy class="btn btn-primary btn-sm">More info</a><br><span id=cookie-credits>Credits to this banner: <a id=cookie-notice-privacy href=https://github.com/Kudos01>Kudos01</a></div></div><script>function createCookie(e,t,n){var s,o="";n&&(s=new Date,s.setTime(s.getTime()+n*24*60*60*1e3),o="; expires="+s.toUTCString()),document.cookie=e+"="+t+o+"; path=/"}function readCookie(e){for(var t,s=e+"=",o=document.cookie.split(";"),n=0;n<o.length;n++){for(t=o[n];t.charAt(0)==" ";)t=t.substring(1,t.length);if(t.indexOf(s)==0)return t.substring(s.length,t.length)}return null}function eraseCookie(e){createCookie(e,"",-1)}if(readCookie("cookie-notice-option")=="true"){function loadScriptAsync(e,t){if(typeof t!="function")throw new Error("Not a valid callback for async script load");var n=document.createElement("script");n.onload=t,n.src=e,document.head.appendChild(n)}loadScriptAsync("https://www.googletagmanager.com/gtag/js?id=G-7KVTDGPL67",function(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","G-7KVTDGPL67",{anonymize_ip:!0})})}else readCookie("cookie-notice-option")!="false"&&(document.getElementById("cookie-notice").style.display="block");document.getElementById("cookie-notice-accept").addEventListener("click",function(){createCookie("cookie-notice-option","true",31),document.getElementById("cookie-notice").style.display="none",location.reload()}),document.getElementById("cookie-notice-deny").addEventListener("click",function(){createCookie("cookie-notice-option","false",31),document.getElementById("cookie-notice").style.display="none",location.reload()})</script></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id=header><a href=https://alright21.github.io><div id=logo style=background-image:url(https://alright21.github.io/images/logo.png)></div><div id=title><h1>Alberto Giust</h1></div></a><div id=nav><ul><li class=icon><a href=# aria-label=Menu><i class="fas fa-bars fa-2x" aria-hidden=true></i></a></li><li><a href=/>Home</a></li><li><a href=/blog>Security Blog</a></li><li><a href=/ctf>CTFs</a></li><li><a href=/education>Education</a></li><li><a href=/about>About</a></li></ul></div></header><article class=post itemscope itemtype=http://schema.org/BlogPosting><div class=content itemprop=articleBody><h1 id=reversing-and-hooking-native-libraries-in-android-with-frida>Reversing and Hooking Native Libraries in Android with Frida</h1><p>Android applications are written in Java (Kotlin): we can use tools like jadx to decompile Java smali code to analyze the code, identify interesting methods and find possible secrets.</p><p>In some cases, Android applications use native libraries to perform some specific tasks: they may be used for root detection, or they can also be responsible for encryption, or simply to run simple tasks, like hide secrets. We can find libraries used inside the apk, by unpacking the <code>.apk</code> using <code>apktool d</code>, inside the <code>/lib</code> folder. Native means that each library is compiled based on the hardware architecture the application will run on, meaning that we will have different folders with the same libraries, but compiled for different architectures.</p><p>How does our application interact with native libraries? If we look inside our decompiled Java code, we can see that our <code>.so</code> file is loaded using <code>System.loadLibrary()</code> function and each method we want to use that is defined inside the native code has the <code>native</code> modifier. Android allows us to write some methods in C and directly call them inside our Java code. How is this magic even possible? Entering JNI, or Java Native Interface [1], an interface framework that defines a way to use C/C++ code in Java.</p><p>We will use as an example the vulnerable application hpAndro [2], and we will solve the challenge &ldquo;Binary Protection -> Native Function Call&rdquo;.</p><p>We can see that inside the Activity <code>NativeFunTaskActivity</code>, the library <code>nativefuncall.so</code> is loaded inside the <code>init()</code> method and then <code>hello()</code> method is called when we press the button.</p><figure><img src=/assets/mobile_security_native_init_method.png alt="init method" style=width:100%><figcaption>Init method sets up a <code>onClickListener</code> that calls native <code>hello()</code></figcaption></figure><p>The goal of the challenge is to call the native method <code>flag()</code>, which is defined inside Activity, but never called. We can use frida to call this method directly, but we need to keep in mind an important thing: we have to call the method after the native library is being called! Where should we do it? We can hook <code>init()</code> method, call it and then call our desired method. An example solution could be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>perform</span>(()=&gt;{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>NativeFunTaskActivity</span> <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>use</span>(<span style=color:#e6db74>&#34;hpandro.android.security.ui.activity.task.binary.NativeFunTaskActivity&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We hook flag method and we print the result before returning
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>NativeFunTaskActivity</span>[<span style=color:#e6db74>&#34;flag&#34;</span>].<span style=color:#a6e22e>implementation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`NativeFunTaskActivity.flag is called`</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>[<span style=color:#e6db74>&#34;flag&#34;</span>]();
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`NativeFunTaskActivity.flag result=</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>result</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We hook init, we call the original method to load the native library, 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//and then we can call flag()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>NativeFunTaskActivity</span>[<span style=color:#e6db74>&#34;init&#34;</span>].<span style=color:#a6e22e>implementation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`NativeFunTaskActivity.init is called`</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>[<span style=color:#e6db74>&#34;init&#34;</span>]();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>[<span style=color:#e6db74>&#34;flag&#34;</span>]();
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=analyze-native-code>Analyze Native Code</h2><p>That&rsquo;s great! But&mldr; hang on a moment: how can we see the code of <code>flag()</code>? We can use Ghidra [3] to disassemble our <code>nativefuncall.so</code>! After opening our library, we are able to see all the native methods listed inside the &ldquo;Functions&rdquo; folder on the left</p><figure><img src=/assets/mobile_security_native_methods.png alt="native methods" style=width:100%><figcaption>Native methods</figcaption></figure><p>We can see that the name of those methods is quite long and does not seem to match our Java methods but, if we look closely, we can see that every method starts with <code>Java_</code>, it is followed by the <code>complete_package_name_structure_</code>, and it ends with <code>methodName</code>. This is how we need to call native methods when working with JNI.</p><p>If we take a look at the decompiled code, we can see that the <code>hello()</code> method returns a Java string, which is hard coded, while the <code>flag()</code> methods does some fancy append to build the string and returns it. In this case, the code seems quite clear, but Ghidra is not able to properly parse JNI symbols [4]. For example, the first argument of every native method must have a pointer to the JNI environment, but Ghidra seems to interpret it as a <code>long*</code>. Luckily, we can import JNI symbols mapping into Ghidra by downloading JNIAnalyzer jdt package [5] (it is also possible to use the plugin directly, but I still have to learn about it).</p><figure><img src=/assets/mobile_security_native_jni.png alt=jnisymbols style=width:100%><figcaption>How to import JNI symobls</figcaption></figure><p>After importing the symbols, we can retype our first argument from <code>long*</code> to <code>JNIEnv*</code>.</p><figure><img src=/assets/mobile_security_native_flag_method.png alt="flag method" style=width:100%><figcaption>Flag method after variable retyping</figcaption></figure><h2 id=hooking-native-methods>Hooking Native Methods</h2><p>We can also hook native methods directly, read the arguments, or modify the return value. Frida will help us with that. We will use <code>Interceptor.attach</code> method to attach to our native function, and then we can use <code>onEnter</code> and <code>onLeave</code> callbacks to interact with native code execution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Interceptor</span>.<span style=color:#a6e22e>attach</span>(<span style=color:#a6e22e>Module</span>.<span style=color:#a6e22e>getExportByName</span>(<span style=color:#e6db74>&#39;libnativefuncall.so&#39;</span>, 
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;Java_hpandro_android_security_ui_activity_task_binary_NativeFunTaskActivity_flag&#39;</span>), {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>onEnter</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>args</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;flag() onEnter: speaking from native&#34;</span>)
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>onLeave</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>retval</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// retval is a native pointer to the result, we need to cast it to java string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>resultString</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>cast</span>(<span style=color:#a6e22e>retval</span>, <span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>use</span>(<span style=color:#e6db74>&#39;java.lang.String&#39;</span>))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;flag() onLeave: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>resultString</span>.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>This code is not sufficient to solve the challenge, since we need to call the <code>flag()</code> method in order to trigger this hook, and we will see an error when loading this script because the library is not being loaded until <code>init()</code> is called. If we merge our scripts, we will see our flag print on the console log, and also when the native method is called.</p><figure><img src=/assets/mobile_security_native_console.png alt="native console" style=width:100%><figcaption>We see the flag printed on the logs</figcaption></figure><h2 id=conclusion>Conclusion</h2><p>Working with native code is an interesting way to learn something new about reverse engineering. I am still learning, so I may have made some mistakes. If you have some feedback, please contact me and I will be eager to learn from you:)</p><h2 id=references>References</h2><ul><li>[1] <a href=https://en.wikipedia.org/wiki/Java_Native_Interface>https://en.wikipedia.org/wiki/Java_Native_Interface</a></li><li>[2] <a href=https://ctf.hpandro.raviramesh.info/>https://ctf.hpandro.raviramesh.info/</a></li><li>[3] <a href=https://ghidra-sre.org/>https://ghidra-sre.org/</a></li><li>[4] <a href=https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html>https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html</a></li><li>[5] <a href=https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni_all.gdt>https://github.com/Ayrx/JNIAnalyzer/blob/master/JNIAnalyzer/data/jni_all.gdt</a></li></ul></div></article><footer id=footer><div class=footer-left>Copyright &copy; 2023 Alberto Giust</div><div class=footer-right><nav><ul><li><a href=/>Home</a></li><li><a href=/blog>Security Blog</a></li><li><a href=/ctf>CTFs</a></li><li><a href=/education>Education</a></li><li><a href=/about>About</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><script src=/lib/jquery/jquery.min.js></script><script src=/js/main.js></script></html>